# 3.1 Осторожное сравнение

## 3.2 Сравниваем осторожно

_Задание._
Aiedra указывает на файл для находящийся рядом BooleanBiter bird. Бедное животное бессмысленно скитается, кажется ей  нужно помочь в поисках правильного сорта пищи. 
```javascript
var nearbyFood = [1, 4, true, "true", false, "0"];
function eatBoolean(food) {
    var x = food.length;
    for (var i = 0; i < x; i++) {
        if ( // Here, the bird needs a condition to check' // ) {
            alert("Yummo. Chirp!");
            nearbyFood.splice(i, 1);
        }
    }
}
```
Когда файл BooleanBiter ищет для булевых значений в неизвестном окружении "food", какой компаратор должен быть использован выше?

_Решение._
Должен использоваться компоратор `===`.

_Пояснение._
Ранее для сравнения мы использовали оператор `==` (проверка на равенство), который, получив операнды разных типов, пытается привести их к одному. Иногда это бывает полезно, а иногда может вызвать проблемы. Так, например true, "true" и 1 будут считаться равными. Чтобы это избежать, применяют оператор строгого сравнения на равенство `===`. В таком случае, если операнды имеют разные типы, то они считаются не равными.

## 3.3 Безопасные по умолчанию

_Задание._
Тройное равно `===` является безопасным по умолчанию. Почему?

_Решение._
Оно проверяет на соответствие `type`, а также `value`.

_Пояснение._
Если операнды имеют разные типы, оператор `===` считает, что они не равны.

## 3.4 Птичка-попрошайка

_Задание._
Голодная нищая птичка бродит на моём пути. Она Stringseeker: ест только строковые части. Это означает, что её любимые угощения такие, как "42", но не противные цифры, как 42! Иногда, однако, отдельные числа находят свой путь в foodPouch.
```javascript
var strength = true;
var fear = false;
var pack = {
    foodPouch: ["carrot", "mystery meat", "apple", 42],
    addFood: function (foodItem) {
        this.foodPouch = this.foodPouch || [];
        this.foodPouch.push(foodItem);
    },
    gobbleFood: function (foodItem) {
        return(this.foodPouch.indexOf(foodItem) > 0 ) ?
            this.foodPouch.splice(this.foodPouch.indexOf(foodItem), 1)[0] :
            alert("Your pack lacks" + foodItem + ", Dhuun.");
    },
    feedBird: function (birdFood) {
        for (var i = 0; i < this.foodPouch.length; i++) {
            if (this.foodPouch[i] == birdFood) {
                alert("Feed beggar bird " + this.foodPouch[i]);
            }
        }
    }
};

pack.feedBird("42");
```
Изменить функцию feedBird так, чтобы числа из моей сумки не попадали к птице, выискивающей строки.

_Решение._
Всё что нужно сделать - заменить равенство (==) на строгое равенство (===) в условии функции feedBird: `if(this.foodPouch[i] === birdFood){}`.

_Пояснение._
См. 3.2.

## 3.5 Птичка является словом

_Задание._
Следует перечитать нижеследующий код, обращая особое внимание на NumberNommer и Bird.
```javascript
function Bird() {}
function DatatypeBird() {}
function SyntaxBird() {}

DatatypeBird.prototype = Object.create(Bird.prototype);
SyntaxBird.prototype = Object.create(Bird.prototype);

var TryCatchTaster = function () {};
TryCatchTaster.prototype = Object.create(SyntaxBird.prototype);

var NumberNommer = function () {};
NumberNommer.prototype = Object.create(DatatypeBird.prototype);

var duneInhabitants = [
    NumberNommer,
    StringSeeker,
    TryCatchTaster,
    SwitchSnagger,
    TernaryTracker,
    BooleanBiter
];
```
NumberNommer новый экземпляр Bird?

_Решение._
`true`, NumberNommer наследует свои свойства от DatatypeBird, который, в свою очередь, является экземпляром Bird.

_Пояснение._
Атрибут прототипа задаёт объект, от которого данный объект наследует свойства. Объекты, созданные с помощью метода Object.create(), получают в качестве прототипа первый аргумент.

## 3.6 Птицы всех оперений

_Задание._
```javascript
function Bird() {}
function DatatypeBird() {...}
DatatypeBird.prototype = Object.create(Bird.prototype);

var NumberNommer = function () {...};
NumberNommer.prototype = Object.create(DatatypeBird.prototype);
```
Какой метод будет установлен, если NumberNommer наследуется от прототипа DatatypeBird и возвращает true?

_Решение._
```javascript
NumberNommer instanceof DatatypeBirds
```

_Пояснение._
Оператор instanceof ожидает 2 операнда: слева - объект, а справа - класс объекта. При этом, если левый операнд является экземпляром класса, указанного в правом операнде, то возвращается true. 

## 3.7 Подсчёт птиц

_Задание._
Как много объектов SyntaxBird населяют дюны? Нужно модифицировать условие в цикле так, чтобы оно проходило через массив duneInhabitants и возвращало конечный результат.
```javascript
function Bird() {}
function DatatypeBird() {}
function SyntaxBird() {}
DatatypeBird.prototype = Object.create(Bird.prototype);
SyntaxBird.prototype = Object.create(Bird.prototype);

var TryCatchTaster = function () {},
    SwitchSnagger = function () {},
    TernaryTracker = function () {};

TryCatchTaster = Object.create(SyntaxBird.prototype);
SwitchSnagger = Object.create(SyntaxBird.prototype);
TernaryTracker = Object.create(SyntaxBird.prototype);

var NumberNommer = function () {},
    StringSeeker = function () {},
    BooleanBiter = function () {};

NumberNommer = Object.create(DatatypeBird.prototype);
StringSeeker = Object.create(DatatypeBird.prototype);
BooleanBiter = Object.create(DatatypeBird.prototype);

var duneInhabitants = [ NumberNommer, StringSeeker, TryCatchTaster,
    SwitchSnagger, TernaryTracker, BooleanBiter ];

var count = 0;
for (var i = 0; i < duneInhabitants.length; i++) {
    if () {
        count++;
    }
}
```

_Решение._
Ставим условие таким образом, чтобы, проходя через каждый элемент duneInhabitants, проверялась его принадлежность к SyntaxBird:
```javascript
if (duneInhabitants[i] instanceof SyntaxBird) {}
```

_Пояснение._
Одним из недостатков оператора instanceof состоит в том, что он не позволяет узнать класс объекта. Он лишь проверяет принадлежность объекта указанному классу.

## 3.8 Наследование моего королевства

_Задание._
Это королевство дюн для птиц. Читая код ниже, следует особое внимание уделить прототипу NumberNommer.
```javascript
function Bird() {}
function DatatypeBird() {...}
function SyntaxBird() {...}
DatatypeBird.prototype = Object.create(Bird.prototype);
SyntaxBird.prototype = Object.create(Bird.prototype);

var TryCatchTaster = function () {...},
    SwitchSnagger = function () {...},
    TernaryTracker = function () {...};

TryCatchTaster.prototype = Object.create(SyntaxBird.prototype);
SwitchSnagger.prototype = Object.create(SyntaxBird.prototype);
TernaryTracker.prototype = Object.create(SyntaxBird.prototype);

var NumberNommer = function () {...},
    StringSeeker = function () {...},
    BooleanBiter = function () {...};

NumberNommer.prototype = Object.create(DatatypeBird.prototype);
StringSeeker.prototype = Object.create(DatatypeBird.prototype);
BooleanBiter.prototype = Object.create(DatatypeBird.prototype);

var duneInhabitants = [NumberNommer, StringSeeker,
    TryCatchTaster, SwitchSnagger, TernaryTracker, BooleanBiter];
```
Будут ли новые экземпляры NumberNommer наследовать оригинальный прототип Bird?

_Решение._
`true`, новые экземпляры NumberNommer будут наследовать оригинальный прототип Bird.

_Пояснение._
Все экземпляры объекта наследуют все свойства всех прототипов этого объекта. Объект Object.prototype - один из редких объектов, не имеющих прототипа и не наследующих никаких свойств. Все встроенные и большинство пользовательских конструкторов имеют прототипы, наследуемые от Object.prototype. Этот связанный ряд прототипов называется "цепочкой прототипов".

## 3.9 Разделение наследования

_Задание._
Читая код ниже, следует особое внимание уделить теперь не только NumberNommer, но и TryCatchTaster.
```javascript
function Bird() {}
function DatatypeBird() {}
function SyntaxBird() {}
DatatypeBird.prototype = Object.create(Bird.prototype);
SyntaxBird.prototype = Object.create(Bird.prototype);

var TryCatchTaster = function () {},
    SwitchSnagger = function () {},
    TernaryTracker = function () {};

TryCatchTaster.prototype = Object.create(SyntaxBird.prototype);
SwitchSnagger.prototype = Object.create(SyntaxBird.prototype);
TernaryTracker.prototype = Object.create(SyntaxBird.prototype);

var NumberNommer = function () {},
    StringSeeker = function () {},
    BooleanBiter = function () {};

NumberNommer.prototype = Object.create(DatatypeBird.prototype);
StringSeeker.prototype = Object.create(DatatypeBird.prototype);
BooleanBiter.prototype = Object.create(DatatypeBird.prototype);

var duneInhabitants = [NumberNommer, StringSeeker,
    TryCatchTaster, SwitchSnagger, TernaryTracker, BooleanBiter];
```
Несмотря на различия, NumberNommers и TryCatchTasters имеют общего предка. Какого?

_Решение._
Прототипом NumberNommers и TryCatchTasters является `Bird`.

_Пояснение._
См. 3.8.