# 3.1 Осторожное сравнение

## 3.2 Сравниваем осторожно

_Задание._
Aiedra указывает на файл для находящийся рядом BooleanBiter bird. Бедное животное бессмысленно скитается, кажется ей  нужно помочь в поисках правильного сорта пищи. 
```javascript
var nearbyFood = [1, 4, true, "true", false, "0"];
function eatBoolean(food) {
    var x = food.length;
    for (var i = 0; i < x; i++) {
        if ( // Here, the bird needs a condition to check' // ) {
            alert("Yummo. Chirp!");
            nearbyFood.splice(i, 1);
        }
    }
}
```
Когда файл BooleanBiter ищет для булевых значений в неизвестном окружении "food", какой компаратор должен быть использован выше?

_Решение._
Должен использоваться компоратор `===`.

_Пояснение._
Ранее для сравнения мы использовали оператор `==` (проверка на равенство), который, получив операнды разных типов, пытается привести их к одному. Иногда это бывает полезно, а иногда может вызвать проблемы. Так, например true, "true" и 1 будут считаться равными. Чтобы это избежать, применяют оператор строгого сравнения на равенство `===`. В таком случае, если операнды имеют разные типы, то они считаются не равными.

## 3.3 Безопасные по умолчанию

_Задание._
Тройное равно `===` является безопасным по умолчанию. Почему?

_Решение._
Оно проверяет на соответствие `type`, а также `value`.

_Пояснение._
Если операнды имеют разные типы, оператор `===` считает, что они не равны.

## 3.4 Птичка-попрошайка

_Задание._
Голодная нищая птичка бродит на моём пути. Она Stringseeker: ест только строковые части. Это означает, что её любимые угощения такие, как "42", но не противные цифры, как 42! Иногда, однако, отдельные числа находят свой путь в foodPouch.
```javascript
var strength = true;
var fear = false;
var pack = {
    foodPouch: ["carrot", "mystery meat", "apple", 42],
    addFood: function (foodItem) {
        this.foodPouch = this.foodPouch || [];
        this.foodPouch.push(foodItem);
    },
    gobbleFood: function (foodItem) {
        return(this.foodPouch.indexOf(foodItem) > 0 ) ?
            this.foodPouch.splice(this.foodPouch.indexOf(foodItem), 1)[0] :
            alert("Your pack lacks" + foodItem + ", Dhuun.");
    },
    feedBird: function (birdFood) {
        for (var i = 0; i < this.foodPouch.length; i++) {
            if (this.foodPouch[i] == birdFood) {
                alert("Feed beggar bird " + this.foodPouch[i]);
            }
        }
    }
};

pack.feedBird("42");
```
Изменить функцию feedBird так, чтобы числа из моей сумки не попадали к птице, выискивающей строки.

_Решение._
Всё что нужно сделать - заменить равенство (==) на строгое равенство (===) в условии функции feedBird: `if(this.foodPouch[i] === birdFood){ }`.

_Пояснение._
См. 3.2.