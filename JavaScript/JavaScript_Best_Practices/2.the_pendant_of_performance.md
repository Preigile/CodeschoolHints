# 2.1 Оптимизация цикла

## 2.2 Убийство дополнительных шагов

_Задание._
Какой лучший способ действий, если нужен громоздкий, повторяющийся доступ к значению внутри JS объекта?

_Решение._
Нужно закэшировать нужное значение в локальной переменной. 

_Пояснение._
Громоздкое условие цикла трудно читать, поэтому, лучше доступ к значению внутри объекта сразу присвоить локальной переменной.

## 2.3 Свойство-головоломка

_Задание._
Я слышу - Aiedra говорит как я пробираюсь сквозь захолустье invertedPeninsula: "В этот раз мы окажемся внутри bitersBog на invertedPeninsula, давольно опасное место для памяти, перезаписи данных и, конечно, скорости. Не смотря на все наши предупреждения, существа здесь добавили много методов к прототипу Array. Теперь они запутались, как должна быть построена их функция populationGetter. В такой ситуации, скажи мне, Dhuun, какой цикл позволит нам построить переменную list в качестве одной строки этих Inverted Pensinsula's critters?"
```javascript
Array.prototype.killTheInsolent = function () { };
Array.prototype.countPopulace = function () { };
Array.prototype.countUndeadPopulace = function () { };
Array.prototype.insecticide = function () { };
Array.prototype.shadowProvider = function () { };

var bitersBog = {
    critters: ["Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"]
};

populationGetter(bitersBog);

function populationGetter(location) {
    var list = "";
    // What sort of loop should go here, Dhuun?
    return list.trim();
}
```
Какой  тип цикла позволит построить список только critters внутри bitersBog?

_Решение._
Поможет нам в этом цикл `For Loop`.

_Пояснение._
С циклами [for](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Road_Trip_Part_2/1.loops.md) мы уже давно знакомы, ровно как и с [for-in](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Road_Trip_Part_3/4.the_ocean_of_objects.md#417-%D0%9F%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-i). Если мы хотим иметь доступ только к свойствам конкретного объекта, без доступа к его прототипам, удобнее работать с циклом for.

## 2.4 Король Кэш

_Задание._
Локальные существа, впечатленые моим решением, строят функцию for-loop. Aeidra одобрительно улыбается мне... или мне всего лишь кажется, что она улыбается. Вскоре её улыбка исчезла...   
"Похоже, что, хоть цикл и выполняет желаемый результат, critters наносит удар по производительности из-за доступа к длине массива на каждой итерации цикла. Давай поможем им, Dhuun. В качестве первого шага, найди способ сохранить важное значение вне цикла. Это заложит начало небольшого прогресса в предотвращении нагрузки процессора."   
Судя по всему, мне нужно построить полезный кэш, я назову переменную numCritters.
```javascript
var bitersBog = {
    critters: ["Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"]
};

populationGetter(bitersBog);

function populationGetter(location) {
    var list = "";

    for (var i = 0; i < location.critters.length; i++) {
        list += location.critters[i];
    }
    return list.trim();
}
```

_Решение._
Непосредственно перед циклом for поместим переменную numCritters, которая определит длину массива, а проверять будем значение этой переменной:
```javascript
var bitersBog = {
    critters: ["Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"]
};

populationGetter(bitersBog);

function populationGetter(location) {
    var list = "";
    var numCritters = location.critters.length;
    for (var i = 0; i < numCritters; i++) {
        list += location.critters[i];
    }
    return list.trim();
}
```

_Пояснение._
Поместив в качестве проверки в цикл свойство length, можно сильно перегрузить процессор. Особенно сильно это будет заметно при работе с большими массивами. Чтобы избежать лишней нагрузке, стоит вычислить длину массива до определения цикла, тогда проверяться будет уже полученное число, а не каждый раз сново вычисленное.

## 2.5 Кусающее болото

_Задание._
Существа советуются с Aeidra в тени. Она плывёт назад ко мне сквозь тайную дымку: "Похоже, эти существа нашли только одно применение для переменной, которую ты построила: единажды внутри цикла. Они попросили перенести кэш так, чтобы он был ближе к тому месту, где используется. Таким образом наступит ясность."   
Для оптимизации организации и эффективности использования памяти нужно переместить переменную в более подходящее место и тщательно подумать о подходящем синтаксисе.

_Решение._
Инициализируем переменную там же, где и i:  
```javascript
var bitersBog = {
    critters: ["Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"]
};

populationGetter(bitersBog);

function populationGetter(location) {
    var list = "";
    for (var i = 0, numCritters = location.critters.length; i < numCritters; i++) {
        list += location.critters[i];
    }
    return list.trim();
}
```

_Пояснение._
Поместив необходимую нам переменную в качестве первого аргумента for, можно добиться того же результата, что и на предыдущем этапе. Немного уменьшится область видимости, но увеличится читаемость. А спомощью ключевого слова var и запятой, мы можем объявлять и инициализировать несколько переменных.

## 2.6 Inverted Peninsula

_Задание._
```javascript
var InvertedPeninsula = function () {
    this.inhabitants = [
        {
            name: "Sir Charles",
            race: "Human"
        },
        {
            name: "Ealei",
            race: "Elf"
        }
    ];

    // Adds an extra `humans` method property to the inhabitants `array` to return all `Humans`
    this.inhabitants.humans = function () { /* returns all Human inhabitants*/
    };
};

// Create a new invertedPeninsula
var invertedPeninsula = new InvertedPeninsula();

// Console.log the `name` of each invertedPeninsula inhabitant
for (var i in invertedPeninsula.inhabitants) {
    console.log(invertedPeninsula.inhabitants[i].name);
}
```
Опасный цикл For-In загневает в неестественной среде обитания полуострова Inverted. Сколько раз будет вызовет метод console.log() из-за сложившейся ситуации при записи имени каждого обитателя?

_Решение._
Метод будет вызван `3` раза.

_Пояснение._
Не смотря на то, что this.inhabitants содержит в себе 2 жителя, правильным ответом будет 3, так как на массив ссылается ещё и функция this.inhabitants.humans.

## 2.7 Повторение сделанного

_Задание._
Несколько новых методов было добавленно в качестве свойств в массив inhabitants и Inverted Peninsula был перемещён в свой собственный JS файл. А мне нужно следать рефакторинг неестественного 'For-In', используя обычный цикл 'For' так, чтобы console.log() выводил только имена обитателей.   
invertedPeninsula.js:
```javascript
var InvertedPeninsula = function () {
    this.inhabitants = [
        {
            name: "Flanery",
            race: "Human"
        },
        {
            name: "Sir Charles",
            race: "Human"
        },
        {
            name: "Ealei",
            race: "Elf"
        },
        {
            name: "Orado",
            race: "Spector"
        }
    ];

    this.inhabitants.getRace = function (race) {
        var members = [];
        for (var i = 0, l = this.length; i < l; i++) {
            if (this[i].race === race) {
                members.push(this[i]);
            }
        }

        return members;
    };

    this.inhabitants.humans = function () {
        return this.getRace('Human');
    };

    this.inhabitants.elves = function () {
        return this.getRace('Elf');
    };

    this.inhabitants.spectors = function () {
        return this.getRace('Spector');
    };
};
```
app.js:
```javascript
// Create a new invertedPeninsula
var invertedPeninsula = new InvertedPeninsula();

// Console.log the name of each invertedPeninsula inhabitant
for (var i in invertedPeninsula.inhabitants) {
    console.log(invertedPeninsula.inhabitants[i].name);
}
```
Технические требования:   
	* Во-первых, удалить повторяющееся свойство цикла For-In   
	* Далее, создать новый цикл, который не выводит в консоль имя каждого жителя   
	* В конце концов, вывести имя каждого обитателя в консоль.   

_Решение._
В файле app.js изменим цикл For-In на обычный For, следуя указанным требованиям:
```javascript
// Create a new invertedPeninsula
var invertedPeninsula = new InvertedPeninsula();

// Console.log the name of each invertedPeninsula inhabitant
for (var i = 0, inhabitants = invertedPeninsula.inhabitants.length; i < inhabitants; i++) {
    console.log(invertedPeninsula.inhabitants[i].name);
}
```

_Пояснение._
Резюмируя:   
	* В объектах, при доступе к конкретным элементам массива, лучше пользоваться циколом for, а не for-in, это избавит от неожиданных результатов, как лишнее вызванное свойство и тп.;   
	* Работая в цикле с массивами, лучше вычислять их длину заранее, это снизит нагрузки на процессор;   
	* Можно делать эти вычисления непосредственно в качестве первого аргумента for, через запятую с остальными переменными, это создаст удобства при чтении;   
	* Если отчёт переменной i идёт от 0 по возрастающей, то она должна проверяться до тех пор, пока _меньше_ длины массива.

# 2.8 Выполнение скрипта

## 2.9 Лучшее место

_Задание._
Мы выходим из Inverted Peninsula, Aiedra плывёт рядом со мной: "Скажи мне, Dhuun, ты знакома с выполнением скрипта. Где лучше расположить тег script, если скриптовый файл очень большой, займёт много времени на загрузку и процесс?"

_Решение._
Такие файлы лучше располагать внизу, перед закрывающим тегом body.

_Пояснение._
Чтобы не прерывать загрузку страницы, рекомендуется располагать тег script непосредственно перед закрывающим тегом body. В этом случае вначале загрузится весь HTML, а затем - наш JavaScript.

## 2.10 Духи скрипта

_Задание._
Духи скрипта поместили волшебный замок на местоположение тега script и, стоит мне переместить его, он тут же возвращается на своё начальное местоположение.   
Неприятный шёпот исходит от духов скрипта, безусловно звучит насмешка.   
Выход один - модифицировать тег, не перемещая его, так, чтобы он позволил странице загружаться без особых задержек.   
```html
<html>
<head>
    <script type="text/javascript" src="https://www.fourlands.com/takesForever.js"></script>
</head>
<body>
/* Mystical Page body html */
</body>
</html>
```

_Решение._
Всё, что требуется - поместить атрибут async в любом месте открывающего тега script:
```html
<html>
<head>
    <script type="text/javascript" src="https://www.fourlands.com/takesForever.js" async></script>
</head>
<body>
/* Mystical Page body html */
</body>
</html>
```

_Пояснение._
Атрибут async указывает парсеру, что данная часть html кода не должна блокировать загрузку остальных частей и может загружать их асинхронно.

## 2.11 Самый медленный в группе

_Задание._
Aeidra рассматривает новый файл: "Будь осторожна, Интенсивно обрабатываемые данные могут всё обломать. Какой из включенных тегов script загрузится медленнее всех?"    
app.html:
```html
<!DOCTYPE>
<html>
<head>
    <script type=text/javascript src="inhabitants.js"></script>
    <script type=text/javascript src="info.js"></script>
    <script type=text/javascript src="inhabitantsProto.js"></script>
    <title>JSBP</title>
</head>
<body>

<h1>Level 2 Inverted Peninsula of Performance</h1>

<h2>Section 3 A blocking <code>script</code> in our path</h2>

<h4>
    Inhabitants of the <em>Inverted Peninsula</em>,
    Popn: <span id="popn"></span>
</h4>
<ul class="unstyled" id="population"></ul>
</body>
</html>
```
inhabitants.js:
```javascript
var invertedPeninsula = {
    inhabitants: [
        "Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"
    ]
};

function populationGetter() {
    var population = invertedPeninsula.inhabitants;
    var list = "";

    for (var i = 0, ff = population.length; i < ff; i++) {
        list += (population[i] + " ");
    }
    return list.trim();
}

populationGetter();
```
info.js:
```javascript
var land = "Inverted Peninsula";
var character = "Dhuun";
var lampsLit = 1;
```
inhabitantsProto.js:
```javascript
Array.prototype.killTheInsolent = function () { };
Array.prototype.countPopulace = function () { };
Array.prototype.countUndeadPopulace = function () { };
Array.prototype.incesticide = function () { };
Array.prototype.shadowProvider = function () { };
```

_Решение._
Медленнее всего будет загружаться `inhabitantsProto.js`.

_Пояснение._
Выполнение кода в HTML идёт по порядку, поэтому, тот скрипт, который расположен выше остальных, загрузится самым первым, а тот, который ниже - последним.

## 2.12 Послабление

_Задание._
Aeidra, кажется, давольна моим прогрессом в скорости анализа. Она просит ещё кое-что: "Ещё раз подтверди своё мастерство в понимании производительности, Dhuun. The Pendant of Performance ждёт. Уменьши время загрузки страницы, переместив тег script, который ищет obeseFile.js в лучшее место."
```html
<!DOCTYPE>
<html>
<head>
    <script type=text/javascript src="inhabitants.js"></script>
    <script type=text/javascript src="largeFile.js"></script>
    <script type=text/javascript src="chunkyFile.js"></script>
    <script type=text/javascript src="obeseFile.js"></script>
    <title>JSBP</title>
</head>
<body>
<h1>Level 2 Inverted Peninsula of Performance</h1>

<h2>Section 3 A blocking <code>script</code> in our path</h2>

<h4>Inhabitants of the <em>Inverted Peninsula</em>, Popn: <span id="popn"></span></h4>
<ul class="unstlyed" id="population"></ul>

</body>
</html>
```

_Решение._
Перенесём скрипт obeseFile.js из head в низ, перед закрывающим тегом body:
```html
<!DOCTYPE>
<html>
<head>
    <script type=text/javascript src="inhabitants.js"></script>
    <script type=text/javascript src="largeFile.js"></script>
    <script type=text/javascript src="chunkyFile.js"></script>
    <title>JSBP</title>
</head>
<body>
<h1>Level 2 Inverted Peninsula of Performance</h1>

<h2>Section 3 A blocking <code>script</code> in our path</h2>

<h4>Inhabitants of the <em>Inverted Peninsula</em>, Popn: <span id="popn"></span></h4>
<ul class="unstlyed" id="population"></ul>
<script type=text/javascript src="obeseFile.js"></script>
</body>
</html>
```

_Пояснение._
Резюмируя:   
	* Тег script лучше всего располагать перед закрывающим body, это ускорит загрузку страницы;
	* Если необходимо поместить script не перед закрывающим body, зорошо использовать атрибут async, чтобы загрузка страницы и скрипта была асинхронной.