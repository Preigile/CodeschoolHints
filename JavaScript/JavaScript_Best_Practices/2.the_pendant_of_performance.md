# 2.1 Оптимизация цикла

## 2.2 Убийство дополнительных шагов

_Задание._
Какой лучший способ действий, если нужен громоздкий, повторяющийся доступ к значению внутри JS объекта?

_Решение._
Нужно закэшировать нужное значение в локальной переменной. 

_Пояснение._
Громоздкое условие цикла трудно читать, поэтому, лучше доступ к значению внутри объекта сразу присвоить локальной переменной.

## 2.3 Свойство-головоломка

_Задание._
Я слышу - Aiedra говорит как я пробираюсь сквозь захолустье invertedPeninsula: "В этот раз мы окажемся внутри bitersBog на invertedPeninsula, давольно опасное место для памяти, перезаписи данных и, конечно, скорости. Не смотря на все наши предупреждения, существа здесь добавили много методов к прототипу Array. Теперь они запутались, как должна быть построена их функция populationGetter. В такой ситуации, скажи мне, Dhuun, какой цикл позволит нам построить переменную list в качестве одной строки этих Inverted Pensinsula's critters?"
```javascript
Array.prototype.killTheInsolent = function () { };
Array.prototype.countPopulace = function () { };
Array.prototype.countUndeadPopulace = function () { };
Array.prototype.insecticide = function () { };
Array.prototype.shadowProvider = function () { };

var bitersBog = {
    critters: ["Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"]
};

populationGetter(bitersBog);

function populationGetter(location) {
    var list = "";
    // What sort of loop should go here, Dhuun?
    return list.trim();
}
```
Какой  тип цикла позволит построить список только critters внутри bitersBog?

_Решение._
Поможет нам в этом цикл `For Loop`.

_Пояснение._
С циклами [for](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Road_Trip_Part_2/1.loops.md) мы уже давно знакомы, ровно как и с [for-in](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Road_Trip_Part_3/4.the_ocean_of_objects.md#417-%D0%9F%D0%B5%D1%80%D0%B5%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-i). Если мы хотим иметь доступ только к свойствам конкретного объекта, без доступа к его прототипам, удобнее работать с циклом for.

## 2.4 Король Кэш

_Задание._
Локальные существа, впечатленые моим решением, строят функцию for-loop. Aeidra одобрительно улыбается мне... или мне всего лишь кажется, что она улыбается. Вскоре её улыбка исчезла...   
"Похоже, что, хоть цикл и выполняет желаемый результат, critters наносит удар по производительности из-за доступа к длине массива на каждой итерации цикла. Давай поможем им, Dhuun. В качестве первого шага, найди способ сохранить важное значение вне цикла. Это заложит начало небольшого прогресса в предотвращении нагрузки процессора."   
Судя по всему, мне нужно построить полезный кэш, я назову переменную numCritters.
```javascript
var bitersBog = {
    critters: ["Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"]
};

populationGetter(bitersBog);

function populationGetter(location) {
    var list = "";

    for (var i = 0; i < location.critters.length; i++) {
        list += location.critters[i];
    }
    return list.trim();
}
```

_Решение._
Непосредственно перед циклом for поместим переменную numCritters, которая определит длину массива, а проверять будем значение этой переменной:
```javascript
var bitersBog = {
    critters: ["Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"]
};

populationGetter(bitersBog);

function populationGetter(location) {
    var list = "";
    var numCritters = location.critters.length;
    for (var i = 0; i < numCritters; i++) {
        list += location.critters[i];
    }
    return list.trim();
}
```

_Пояснение._
Поместив в качестве проверки в цикл свойство length, можно сильно перегрузить процессор. Особенно сильно это будет заметно при работе с большими массивами. Чтобы избежать лишней нагрузке, стоит вычислить длину массива до определения цикла, тогда проверяться будет уже полученное число, а не каждый раз сново вычисленное.

## 2.5 Кусающее болото

_Задание._
Существа советуются с Aeidra в тени. Она плывёт назад ко мне сквозь тайную дымку: "Похоже, эти существа нашли только одно применение для переменной, которую ты построила: единажды внутри цикла. Они попросили перенести кэш так, чтобы он был ближе к тому месту, где используется. Таким образом наступит ясность."   
Для оптимизации организации и эффективности использования памяти нужно переместить переменную в более подходящее место и тщательно подумать о подходящем синтаксисе.

_Решение._
Инициализируем переменную там же, где и i:  
```javascript
var bitersBog = {
    critters: ["Nipping Global Variable",
        "Sneaky For-in",
        "Bulging Blocking Script"]
};

populationGetter(bitersBog);

function populationGetter(location) {
    var list = "";
    for (var i = 0, numCritters = location.critters.length; i < numCritters; i++) {
        list += location.critters[i];
    }
    return list.trim();
}
```

_Пояснение._
Поместив необходимую нам переменную в качестве первого аргумента for, можно добиться того же результата, что и на предыдущем этапе. Немного уменьшится область видимости, но увеличится читаемость. А спомощью ключевого слова var и запятой, мы можем объявлять и инициализировать несколько переменных.

## 2.6 Inverted Peninsula

_Задание._
```javascript
var InvertedPeninsula = function () {
    this.inhabitants = [
        {
            name: "Sir Charles",
            race: "Human"
        },
        {
            name: "Ealei",
            race: "Elf"
        }
    ];

    // Adds an extra `humans` method property to the inhabitants `array` to return all `Humans`
    this.inhabitants.humans = function () { /* returns all Human inhabitants*/
    };
};

// Create a new invertedPeninsula
var invertedPeninsula = new InvertedPeninsula();

// Console.log the `name` of each invertedPeninsula inhabitant
for (var i in invertedPeninsula.inhabitants) {
    console.log(invertedPeninsula.inhabitants[i].name);
}
```
Опасный цикл For-In загневает в неестественной среде обитания полуострова Inverted. Сколько раз будет вызовет метод console.log() из-за сложившейся ситуации при записи имени каждого обитателя?

_Решение._
Метод будет вызван `3` раза.

_Пояснение._
Не смотря на то, что this.inhabitants содержит в себе 2 жителя, правильным ответом будет 3, так как на массив ссылается ещё и функция this.inhabitants.humans.

## 2.7 Повторение сделанного

_Задание._
Несколько новых методов было добавленно в качестве свойств в массив inhabitants и Inverted Peninsula был перемещён в свой собственный JS файл. А мне нужно следать рефакторинг неестественного 'For-In', используя обычный цикл 'For' так, чтобы console.log() выводил только имена обитателей.   
invertedPeninsula.js:
```javascript
var InvertedPeninsula = function () {
    this.inhabitants = [
        {
            name: "Flanery",
            race: "Human"
        },
        {
            name: "Sir Charles",
            race: "Human"
        },
        {
            name: "Ealei",
            race: "Elf"
        },
        {
            name: "Orado",
            race: "Spector"
        }
    ];

    this.inhabitants.getRace = function (race) {
        var members = [];
        for (var i = 0, l = this.length; i < l; i++) {
            if (this[i].race === race) {
                members.push(this[i]);
            }
        }

        return members;
    };

    this.inhabitants.humans = function () {
        return this.getRace('Human');
    };

    this.inhabitants.elves = function () {
        return this.getRace('Elf');
    };

    this.inhabitants.spectors = function () {
        return this.getRace('Spector');
    };
};
```
app.js:
```javascript
// Create a new invertedPeninsula
var invertedPeninsula = new InvertedPeninsula();

// Console.log the name of each invertedPeninsula inhabitant
for (var i in invertedPeninsula.inhabitants) {
    console.log(invertedPeninsula.inhabitants[i].name);
}
```
Технические требования:   
	* Во-первых, удалить повторяющееся свойство цикла For-In   
	* Далее, создать новый цикл, который не выводит в консоль имя каждого жителя   
	* В конце концов, вывести имя каждого обитателя в консоль.   

_Решение._
В файле app.js изменим цикл For-In на обычный For, следуя указанным требованиям:
```javascript
// Create a new invertedPeninsula
var invertedPeninsula = new InvertedPeninsula();

// Console.log the name of each invertedPeninsula inhabitant
for (var i = 0, inhabitants = invertedPeninsula.inhabitants.length; i < inhabitants; i++) {
    console.log(invertedPeninsula.inhabitants[i].name);
}
```

_Пояснение._
Резюмируя:   
	* В объектах, при доступе к конкретным элементам массива, лучше пользоваться циколом for, а не for-in, это избавит от неожиданных результатов, как лишнее вызванное свойство и тп.;   
	* Работая в цикле с массивами, лучше вычислять их длину заранее, это снизит нагрузки на процессор;   
	* Можно делать эти вычисления непосредственно в качестве первого аргумента for, через запятую с остальными переменными, это создаст удобства при чтении;   
	* Если отчёт переменной i идёт от 0 по возрастающей, то она должна проверяться до тех пор, пока _меньше_ длины массива.