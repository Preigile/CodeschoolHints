# 4.1 Основы пространства имён

## 4.2 Группировка и защита

_Задание._
Как называется объект, который группирует и защищает соответствующие данные и методы?

_Решение._
Такой объект называется `Namespace`.

_Пояснение._
Namespace (пространство имён) — некоторое множество, под которым подразумевается модель, абстрактное хранилище или окружение, созданное для логической группировки уникальных идентификаторов (то есть имён). 

## 4.3 Доказательство своей значимости

_Задание._
"Загадки, загадки; не очень весело. Докажи свою ценность, Dhuun, конец близок."  
Приложение, которое имеет несколько файлов, содержащих переменные с одинаковыми именами, будет испытывать потерю данных в случае 1.__________, которая стирает старые данные в пользу новых (и, возможно, неправильных). Это происходит именно тогда, когда эти переменные объявлены 2.__________ в нескольких файлах. Эта ошибка не может быть обнаружена до 3.__________. 

_Решение._
Приложение, которое имеет несколько файлов, содержащих переменные с одинаковыми именами, будет испытывать потерю данных в случае перезаписи (overwrite), которая стирает старые данные в пользу новых (и, возможно, неправильных). Это происходит именно тогда, когда эти переменные объявлены глобально (globally) в нескольких файлах. Эта ошибка не может быть обнаружена до выполнения программы (run-time). 

_Пояснение._
Приоритет будет иметь тот файл, который добавлен ниже в HTML. Такую ошибку не легко обнаружить сразу, но она может кординально изменить конечный результат.

## 4.4 Вход в пещеры

_Задание._
"Смотри," - говорит Aiedra, - "это файл cavesofclarity.js! Данные внутри него в настоящее время глобальны и уязвимы для зла. Преобразуй этот файл так, чтобы он содержал в себе только один объект, который защитит данные."
```javascript
var stalactites = 4235;
var stalagmites = 3924;
var bats = 345;
var treasureChests = 3;
var openChest = function () {
    treasureChests--;
    alert("DA DADADA DAAAAAAA!");
};
```

_Решение._
Создадим в файле глобальный объект CAVESOFCLARITY, а все переменные сделаем его свойствами; не забудем в функции применить this:
```javascript
var CAVESOFCLARITY = {
    stalactites: 4235,
    stalagmites: 3924,
    bats: 345,
    treasureChests: 3,
    openChest: function () {
        this.treasureChests--;
        alert("DA DADADA DAAAAAAA!");
    }
};
```

_Пояснение._
Теперь глобальные переменные стали локальными свойствами одного Namespace обекта. Его отличае от остальных объектов в том, что он идентифицируется заглавными буквами.

## 4.5 Доступ предоставляется

_Задание._
"HTML страница для Caves of Clarity сейчас скрывается в темноте," - заметила Aiedra. - "Она потеряла доступ к данным, которые когда-то были глобальными. Освети своим факелом эту одинокую линию, обеспеч открытие сундука и слушай музыку."
```html 
<!DOCTYPE>
<html>
    <body>
        <h1>Level 4 Caves of Clarity</h1>
        <script type="text/javascript" src="cavesofclarity.js"></script>
        <button onclick="openChest();"> Open the Secret Treasure!</button>
    </body>
</html>
```

_Решение._
Перед вызовом функции добавим имя объекта:
```html
<button onclick="CAVESOFCLARITY.openChest();"> Open the Secret Treasure! </button>
```

_Пояснение._
Теперь, чтобы получить доступ к требуемым данным, будем вызывать свойства объекта.

## 4.6 Защита или пиратство?

_Задание._
Проходя ещё глубже в пещеру, я столкнулась с одноногим человеком. Сидя лицом к грубой стене, он покосился на меня исподлобья утверждая: "Namespace гарантирует полную защиту данных."   
Так ли это?

_Решение._
`False`, Namespace не гарантирует полную защиту данных.

_Пояснение._
Namespace не может полностью защитить данные. Так, к примеру кто-то может задать Namespace с тем же идентификатором. Но проверить имя одного объекта гораздо проще, чем всего содержимого документа.

## 4.7 Сундук с сокровищами

_Задание._
Пещерам нужна немного лучшая защита для их treasureChests. Используя свои знания о "вложениях",  я должна построить новый контейнер внутри существующего. Для этого нужно добавить переменную treasureChests и метод, который сопровождает открытие сундука. Можно назвать этот контейнер SECRET.

_Решение._
Внутри объекта CAVESOFCLARITY создадим свойство SECRET в качестве объекта со свойством treasureChests и методом openChest:
```javascript
var CAVESOFCLARITY = {
    stalactites: 4235,
    stalagmites: 3924,
    bats: 345,
    SECRET: {
        treasureChests: 3,
        openChest: function () {
            this.treasureChests--;
            alert("DA DADADA DAAAAAAA!");
        }
    }
};
```

_Пояснение._
Помещая один объект Namespace в другой, можно обеспечить большую защиту. Второе пространство имени оформляется так же, как обычное свойство, только именуется всеми заглавными буквами.

## 4.8 Секреты

_Задание._
"Увы, HTML страница снова погрузилась во тьму," - обратила внимание Aiedra. - "Верни освещение, перемодифицировав вызов функции для размещённого тобой нового вложения."

_Решение._
Теперь openChest является методом SECRET, поэтому доступ к нему немного изменился:
```javascript
<!DOCTYPE>
<html>
  <body>
    <h1>Level 4 Caves of Clarity</h1>
    <script type="text/javascript" src="cavesofclarity.js"></script>
    <button onclick="CAVESOFCLARITY.SECRET.openChest();"> Open the Secret Treasure! </button>
  </body>
</html>
```

_Пояснение._
См. 4.2-4.7.

## 4.9 Неосведомлённый

_Задание._
Aiedra снисходительно улыбается: "Ты преуспела в доведении Namespace в пещеры. Ещё один вопрос, прежде чем мы отправимся дальше вниз, в темноту..."  
Она проплывает мимо меня, перед твёрдой каменной стеной: "Этот путь закрыт, но остался один пароль. Возможно, ты помнишь, что, если другой файл с другим пространством имени понадобится HTML файлу Caves, то два файла не должны знать друг о друге, если это не запланированно. Это полезное блокирование информации помогает тебе в защите данных... какой термин существует для такого незнания, Dhuun?"

_Решение._
Независимость файлов называется `agnostic`.

_Пояснение._
Файлы agnostic работают вместе только при условии, что у каждого своё пространство имён. 