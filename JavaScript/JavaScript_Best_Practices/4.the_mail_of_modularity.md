# 4.1 Основы пространства имён

## 4.2 Группировка и защита

_Задание._
Как называется объект, который группирует и защищает соответствующие данные и методы?

_Решение._
Такой объект называется `Namespace`.

_Пояснение._
Namespace (пространство имён) — некоторое множество, под которым подразумевается модель, абстрактное хранилище или окружение, созданное для логической группировки уникальных идентификаторов (то есть имён). 

## 4.3 Доказательство своей значимости

_Задание._
"Загадки, загадки; не очень весело. Докажи свою ценность, Dhuun, конец близок."  
Приложение, которое имеет несколько файлов, содержащих переменные с одинаковыми именами, будет испытывать потерю данных в случае 1.__________, которая стирает старые данные в пользу новых (и, возможно, неправильных). Это происходит именно тогда, когда эти переменные объявлены 2.__________ в нескольких файлах. Эта ошибка не может быть обнаружена до 3.__________. 

_Решение._
Приложение, которое имеет несколько файлов, содержащих переменные с одинаковыми именами, будет испытывать потерю данных в случае перезаписи (overwrite), которая стирает старые данные в пользу новых (и, возможно, неправильных). Это происходит именно тогда, когда эти переменные объявлены глобально (globally) в нескольких файлах. Эта ошибка не может быть обнаружена до выполнения программы (run-time). 

_Пояснение._
Приоритет будет иметь тот файл, который добавлен ниже в HTML. Такую ошибку не легко обнаружить сразу, но она может кординально изменить конечный результат.

## 4.4 Вход в пещеры

_Задание._
"Смотри," - говорит Aiedra, - "это файл cavesofclarity.js! Данные внутри него в настоящее время глобальны и уязвимы для зла. Преобразуй этот файл так, чтобы он содержал в себе только один объект, который защитит данные."
```javascript
var stalactites = 4235;
var stalagmites = 3924;
var bats = 345;
var treasureChests = 3;
var openChest = function () {
    treasureChests--;
    alert("DA DADADA DAAAAAAA!");
};
```

_Решение._
Создадим в файле глобальный объект CAVESOFCLARITY, а все переменные сделаем его свойствами; не забудем в функции применить this:
```javascript
var CAVESOFCLARITY = {
    stalactites: 4235,
    stalagmites: 3924,
    bats: 345,
    treasureChests: 3,
    openChest: function () {
        this.treasureChests--;
        alert("DA DADADA DAAAAAAA!");
    }
};
```

_Пояснение._
Теперь глобальные переменные стали локальными свойствами одного Namespace обекта. Его отличае от остальных объектов в том, что он идентифицируется заглавными буквами.

## 4.5 Доступ предоставляется

_Задание._
"HTML страница для Caves of Clarity сейчас скрывается в темноте," - заметила Aiedra. - "Она потеряла доступ к данным, которые когда-то были глобальными. Освети своим факелом эту одинокую линию, обеспеч открытие сундука и слушай музыку."
```html 
<!DOCTYPE>
<html>
    <body>
        <h1>Level 4 Caves of Clarity</h1>
        <script type="text/javascript" src="cavesofclarity.js"></script>
        <button onclick="openChest();"> Open the Secret Treasure!</button>
    </body>
</html>
```

_Решение._
Перед вызовом функции добавим имя объекта:
```html
<button onclick="CAVESOFCLARITY.openChest();"> Open the Secret Treasure! </button>
```

_Пояснение._
Теперь, чтобы получить доступ к требуемым данным, будем вызывать свойства объекта.

## 4.6 Защита или пиратство?

_Задание._
Проходя ещё глубже в пещеру, я столкнулась с одноногим человеком. Сидя лицом к грубой стене, он покосился на меня исподлобья утверждая: "Namespace гарантирует полную защиту данных."   
Так ли это?

_Решение._
`False`, Namespace не гарантирует полную защиту данных.

_Пояснение._
Namespace не может полностью защитить данные. Так, к примеру кто-то может задать Namespace с тем же идентификатором. Но проверить имя одного объекта гораздо проще, чем всего содержимого документа.

## 4.7 Сундук с сокровищами

_Задание._
Пещерам нужна немного лучшая защита для их treasureChests. Используя свои знания о "вложениях",  я должна построить новый контейнер внутри существующего. Для этого нужно добавить переменную treasureChests и метод, который сопровождает открытие сундука. Можно назвать этот контейнер SECRET.

_Решение._
Внутри объекта CAVESOFCLARITY создадим свойство SECRET в качестве объекта со свойством treasureChests и методом openChest:
```javascript
var CAVESOFCLARITY = {
    stalactites: 4235,
    stalagmites: 3924,
    bats: 345,
    SECRET: {
        treasureChests: 3,
        openChest: function () {
            this.treasureChests--;
            alert("DA DADADA DAAAAAAA!");
        }
    }
};
```

_Пояснение._
Помещая один объект Namespace в другой, можно обеспечить большую защиту. Второе пространство имени оформляется так же, как обычное свойство, только именуется всеми заглавными буквами.

## 4.8 Секреты

_Задание._
"Увы, HTML страница снова погрузилась во тьму," - обратила внимание Aiedra. - "Верни освещение, перемодифицировав вызов функции для размещённого тобой нового вложения."

_Решение._
Теперь openChest является методом SECRET, поэтому доступ к нему немного изменился:
```javascript
<!DOCTYPE>
<html>
  <body>
    <h1>Level 4 Caves of Clarity</h1>
    <script type="text/javascript" src="cavesofclarity.js"></script>
    <button onclick="CAVESOFCLARITY.SECRET.openChest();"> Open the Secret Treasure! </button>
  </body>
</html>
```

_Пояснение._
См. 4.2-4.7.

## 4.9 Неосведомлённый

_Задание._
Aiedra снисходительно улыбается: "Ты преуспела в доведении Namespace в пещеры. Ещё один вопрос, прежде чем мы отправимся дальше вниз, в темноту..."  
Она проплывает мимо меня, перед твёрдой каменной стеной: "Этот путь закрыт, но остался один пароль. Возможно, ты помнишь, что, если другой файл с другим пространством имени понадобится HTML файлу Caves, то два файла не должны знать друг о друге, если это не запланированно. Это полезное блокирование информации помогает тебе в защите данных... какой термин существует для такого незнания, Dhuun?"

_Решение._
Независимость файлов называется `agnostic`.

_Пояснение._
Файлы agnostic работают вместе только при условии, что у каждого своё пространство имён.

# 4.10 Анонимное замыкание

## 4.11 Немного того, немного этого

_Задание._
Какая функция используется для вызова нескольких приватных параметров, связанных только с окружающей функцией и нескольких публичных свойств, доступных для всех держателей namespace?

_Решение._
Такой функцией является `anonymous closures`.

_Пояснение._
Иногда хочется оставить некоторые свойства приватными, а некоторые оставить доступными. В таких случаях можно использовать анонимное замыкание (anonymous closures).

## 4.12 Приватный против публичного

_Задание._
Другая массивная стена появилась после длинного пути. На её поверхности выводятся ломаные фразы в светящемся скрипте. Aiedra шепчет, как бы про себя: "Знания дадут ключ. Покажи своё понимание сложных модулей. Подумай хорошенико... найди правильные слова."   
__________ свойства __________ в локальной области видимости __________.   
__________ свойства построены в __________, который затем __________, чтобы стать __________.   
Доступ к __________ данным, таким образом, возможен только потому, что __________ внутри самого большого __________.      
Размышляя над ответом, я отодвинула мысль, что она была сдесь раньше.

_Решение._
Приватные (private) свойства созданны (created) в локальной области видимости функционального выражения (function expression).   
Пибличные (public) свойства построены в объекте (object), который затем возвращается (returned), чтобы стать пространством имён (namespace).   
Доступ к приватным (private) данным, таким образом, возможен только потому, что закрыт (closure) внутри самого большого модуля (module).   

_Пояснение._
В анонимном замыкании приватные свойства создаются в локальной области видимости, а публичные возвращаются в виде объекта.

## 4.13 Построение приватных данных

_Задание._
"Вместо использования только вложенного namespace," - заметила Aiedra, - "Давай создадим модуль CAVESOFCLARITY, где количество ящиков с сокровищами сделаем приватным через ананимное замыкание."    
Она подняла взгляд на потолок пещеры: "Сейчас мы позволим геологическим созданиям и взможностям таким, как метод для открытия ящиков, остаться публичными, доступными через пространство имён."   
Указывая на файл cavesofclarity.js, она обозначает место для моих осторожных изменений: "Ты должна использовать свои знания создания публичных и приватных свойств в модуле, чтобы вноь тщательно организовать данные. Так ты увеличишь безопасность пещер."   
1) Для начала сделать treasureChests приватным, преобразовав CAVESOFCLARITY в анонимное замыкание, которое возвращает объект с оригинальными данными;   
2) Затем для CAVESOFCLARITY инициализированном как результат замыкания, сделать непосредственный вызов замыкания;   
3) В конце концов, сделать свойство treasureChests приватным путём локального объявления переменной внутри замыкания.

_Решение._
Создадим анонимное замыкание и его вызов. В return поместим объект, содержащий в себе те же свойства, что и CAVESOFCLARITY. Из объекта SECRET вынесем свойство treasureChests, сделав его локальной переменной. А в методе openChest удалим this, так как treasureChests больше не свойство:
```javascript
var CAVESOFCLARITY = (function () {
    var treasureChests = 3;
    return {stalactites: 4235,
        stalagmites: 3924,
        bats: 345,
        SECRET: {
            openChest: function () {
                treasureChests--;
                alert("DA DADADA DAAAAAAA!");
            }
        }
    };
})();
```

_Пояснение._
Структура анонимного замыкания:
```javascript
var ИМЕННОЕПРОСТРАНСТВО = (function () {
    var скрытыеСвойства = "значение";
    return {
        отображаемыеСвойства: "значение"
    };
})();

## 4.14 Публичное под влиянием приватного

_Задание._
На какой оператор, при выполнении, окажет влияние приватное свойство?

_Решение._
Приватное свойство окажет влияние на `treasureChests--;`.

_Пояснение._
Приватное свойство не видимо для пользователя, но с ним можно производить различные действия внутри публичного.

## 4.15 Безопасность летучих мышей

_Задание._
Aiedra услышала что-то вдалеке. После короткого молчания она сказала: "Пещеры пропели мне тихо. Они хотят защитить своих существ. Модифицируй модуль, сделав данные bats приватными."

_Решение._
Сделаем свойство bats локальной переменной:
```javascript
var CAVESOFCLARITY = function () {

    var treasureChests = 3;
    var bats = 345;

    return {
        stalactites: 4235,
        stalagmites: 3924,
        SECRET: {
            openChest: function () {
                treasureChests--;
                alert("DA DADADA DAAAAAAA!");
            }
        }
    };
}();
```

_Пояснение._
См. 4.12-4.14.

## 4.16 Бесполезное замыкание

_Задание._
"Несмотря на то, что ты эффективно сделала количество bats приватным, мне интересно, сможешь ли ты увидеть проблему, которая за этим последовала?" - Aiedra терпеливо ждёт моего анализа. Что произошло?

_Решение._
Поскольку на bats никогда не ссылаются через публичные методы, его данные не несут в себе никакой функциональной нагрузки.

_Пояснение._
См. Решение.

## 4.17 Летучие мыши на все времена

_Задание._
"Чтобы гарантировать, что на количество летучих мышей будет ссылка, построй публичный метод getBats, который вернёт это приватное свойство. Из твоей хорошей работы сумма мышей бедет извлекаема, но количество останется на века."   
1) Для начала, нужно создать функцию getBats в возвращаемом объекте замыкания;   
2) Показать значение bats внешнему миру.

_Решение._
В возвращаемом объекте создадим метод getBats, который вернёт bats:
```javascript
var CAVESOFCLARITY = function () {

    var treasureChests = 3;
    var bats = 345;

    return {
        stalactites: 4235,
        stalagmites: 3924,
        SECRET: {
            openChest: function () {
                treasureChests--;
                alert("DA DADADA DAAAAAAA!");
            }
        },
        getBats: function () {
            return bats;
        }
    };
}();
```

_Пояснение._
Доступ к публичным объектам подобен доступу к [свойствам Namespace](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Best_Practices/4.the_mail_of_modularity.md#45-%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F): нужно обозначить именное пространство, а затем идентификатор свойства (к примеру, CAVESOFCLARITY.getBats).

## 4.18 iife\*

\* Возможно, имелось в виду life

_Задание._
"Ты хорошо справлялась до сих пор," - сказала Aiedra, когда мы приблизились к подземному озеру. Вода успокаивает и мерцает, как стекло, от света моего факела.   
"Ответ на финальный вопрос призовёт лодку, которая переправит тебя на другой берег," - она проплывает над водой, оставляя меня на берегу в темноте. - "Что даст возможность переменной CAVESOFCLARITY, непосредственно содержать объект, который служит в качестве модуля, а не функции?"

_Решение._
Скобки, которые непосредственно запускают функцию.

_Пояснение._
Нельзя забывать ставить круглые скобки вызова анонимной функции сразу после её определения, иначе все усилия будут напрасны.