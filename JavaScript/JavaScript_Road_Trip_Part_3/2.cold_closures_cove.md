# 2.1 Раздел 1 - Концепция замакания

## 2.2 Следим за замыканиями I

_Задание._
После изучения кода ниже, вычислить финальное значение переменной result и вывести это значение на экран в качестве числа, используя одну линию кода.
```javascript
var hidden = mystery();
var result = hidden(3);

function mystery() {
    var secret = 6;

    function mystery2(multiplier) {
        multiplier *= 3;
        return secret * multiplier;
    }

    return mystery2;
}
```

_Решение._
В задании просится вывести числовое значение. Вычисляем его, получаем 54:
```javascript
alert(54);
```

_Пояснение._
Функция mystery возвращает mystery2 в том виде, как она есть, так как в return mystery2 не стоят круглые скобки. Переменная hidden принимает значение mystery() и оставляет его равным самой функции mystery2. Чтобы получить конкретное значение, переменной result присваивается hidden с конкретным аргументом. Круглые скобки в этом случае позволят получить не саму функцию mystery2, а её значение, где в качестве аргумента multiplier будет выступать число 3. В итоге проводим необходимые математические операции, чтобы вычислить нужное значение.

## 2.3 Следим за замыканиями II
 
_Задание._
На этот раз код стал немного сложнее. Опять же, нужно вывести значение на экран в качестве числа, используя одну линию кода.
```javascript
var hidden = mystery(4);
var result = hidden(2);

function mystery(input) {
    var secret = 5;

    function mystery2(multiplier) {
        multiplier *= input;
        return secret * multiplier;
    }

    return mystery2;
}
```

_Решение._
Снова вычисляем значение, получаем 40:
```javascript
alert(40);
```

_Пояснение._
В этот раз используется 2 аргумента. Теперь появился аргумент у функции mystery, который в переменной hidden обозначен как 4. Значение же аргумента mystery2 теперь равно 2.

## 2.4 Следим за замыканиями III

_Задание._
Ещё сложнее! Снова, рассчитать конечное значение переменной result и вывести его в виде числа с помощью одной строки кода. 
```javascript
var hidden = mystery(3);
var jumble = mystery3(hidden);
var result = jumble(2);

function mystery(input) {
    var secret = 4;
    input += 2;
    function mystery2(multiplier) {
        multiplier *= input;
        return secret * multiplier;
    }

    return mystery2;
}
function mystery3(param) {
    function mystery4(bonus) {
        return param(6) + bonus;
    }

    return mystery4;
}
```


_Решение._
Добавляется ещё две функции и ещё одна переменная. В итоге получаем 122:
```javascript
alert(122);
```

_Пояснение._
Легко работать с двумя функциями и двумя переменными. Когда же их становиться больше, нужно научиться распутывать получившуюся паутинку. В данном случае переменные идут по порядку, одна содержит в значении другую. Следовательно решение нужно начать с первой - hidden. Она принимает значение функции mystery с аргументом 3 (input), которая выводит функцию mystery2 целиком. С этим всё понятно.  
Следующая переменная - jumble. Она принимает значение mystery3 с аргументом hidden, следовательно возвращает функцию mystery4 целиком. В функцие mystery4 param принимает аргумент 6, что можно сопоставить с hidden(6), что в свою очередь задаёт аргумент функции mystery2. В итоге результат переменной jumble составляет 122.  
Последним шагом нужно найти значение переменной result. Изначально ей присвоено значение jumble с аргументом 2. Данный аргумент присваивается функцие mystery4. Конечный результат получаем 122.

## 2.5 Построение замыкания I

_Задание._
Девушкам разработчикам в the Cold Closures Cove иногда нужно сообщать путешественникам о различных препятствиях, которые время от времени приплывают в бухточку. Однако они нуждаются в помощи. Они приготовили очень эффективное предупреждение, которое позволит им предупреждать только когда они должны, и только когда им это нужно. Замыкание в помощь!
Ниже, они начали функцию для вызова warningMaker с параметром obstacle. В этой функции построить и вернуть другую функцию, которая выводит конкретное сообщение, основанное на специфике тревожащего объекта столкновения. Формат сообщения должен быть следующим: 
```
"Beware! There have been <obstacle> sightings in the Cove today!"
```

_Решение._
В уже готовой функцие warningMaker возвращаем другую анонимную функцию с необходимым сообщением:
```javascript
function warningMaker(obstacle) {
    return function () {
        alert("Beware! There have been " + obstacle +
        		" sightings in the Cove today!");
    };
}
```

_Пояснение._
Возвращение функции из функции, в комплекте с переменными из внешней области видимости, называется замыканием. За пределами крайней функции будет доступно всё содержимое помещённой в неё функции. Замыкание охватывает целую среду, связывающую необходимые переменные из других областей. Внутренняя функция может обращаться к переменным внешней функции, потому что они "чувствуют себя" как глобальные переменные. Им не нужно храниться где-либо во внутренней функции, даже в аргументах. Замыкание может сделать создание очень похожих функций сверх эффективными. 

## 2.6 Использование замыкания I

_Задание._
The Cove’s Dev Girls только что получили сообщение об айсберге в   области! Используя новый производитель предупреждений, построить предупреждающую функцию для препятствующего айсберга и сохранить её в переменной icebergAlert. Затем вызвать эту функцию.

_Решение._
Присваиваем переменной icebergAlert существующую функцию со значением "iceberg", а затем вызываем анонимную функцию:
```javascript
function warningMaker(obstacle) {
    return function () {
        alert("Beware! There have been " + obstacle + 
						"sightings in the Cove today!");
    };
}

var icebergAlert = warningMaker("iceberg");
icebergAlert();
}
```

_Пояснение._
В прошлом уровне мы узнали, что функция может содержать в себе другую функцию. Если написать имя функции-матери с одними круглыми скобками, то мы получим функцию-дочь целиком; если же поставить две пары скобок, то к нам попадёт дочерний результат. Данный пример мы могли бы решить в одну строку, но в задании требуется именно этот вариант.

## 2.7 Построение замыкания II

_Задание._
The Dev Girls восхищаются моим явным мастерством). Чтобы проверить мощь, они попросили изменить warningMaker в объявленном порядке:  
1. количество помех  
2. конкретное расположение найденного препятствия  
Другими словами, они хотели бы передавать конкретное количество и расположение любой предупреждающей функцией, которую они уже создали и использовать эти значения в качестве сообщения.
Наша старая функция уже в редакторе. Формат нового сообщения представлен ниже. Имена новых аргументов находятся в скобках:
```
"Beware! There have been <obstacle> sightings in the Cove today!
<number> <obstacle>(s) spotted at the <location>!"
```

_Решение._
В анонимную функцию помещаем 2 аргумента: количество и положение помех и добавляем их в сообщение вместе с необходимым текстом: 
```javascript
function warningMaker(obstacle) {
    return function (number, location) {
        alert("Beware! There have been " + obstacle + 
						" sightings in the Cove today!\n" +
            number + " " + obstacle + "(s) spotted at the " + 
						location + "!"
        );
    };
}
```

_Пояснение._
Внутренняя функция может быть как без аргументов, так и с любым их количеством. Если бы мы поместили все аргументы в warningMaker, то результат не изменится (правда тогда потеряется гибкость), однако, если перенести аргумент из внешней функции, их они будут доступны только во внутренней. 

## 2.8 Использование замыкания II

_Задание._
Улучшенная функциональность предупреждающих сообщений произвела впечатление на the Dev Girls. Они построили несколько генераторов предупреждения и готовы к любой опасности. Вдруг радио стало потрескивать.
*Статически* Dev Girls, сигнал бедствия. Dev Girls, сигнал бедствия. У меня 6 убийц пингвинов на свободе возле "Ледяной пещеры", и 1 снежный йети буйствует на той стороне "Метель-Бич". Повторяю, 6 убийц пингвинов, "Ледяные пещеры", 1 снежный йети, "Метель-Бич". Конец связи! *Статически*
Просмотреть уже построенное предупреждающее сообщение и вызвать соответствующие функции для этой ситуации, убедившись, что они переданны в соответствующих параметрах. Всё это займёт только 2 строки кода. 

_Решение._
Вконце готового кода пишем 2 строки с именем подходящих переменных и необходимыми аргументами:
```javascript
function warningMaker(obstacle) {
    return function (number, location) {
        alert("Beware! There have been " + obstacle + 
						" sightings in the Cove today!\n" +
            number + " " + obstacle + "(s) spotted at the " + 
						location + "!"
        );
    };
}
var killerPenguinAlert = warningMaker("killer penguin");
var polarBearAlert = warningMaker("polar bear");
var icebergAlert = warningMaker("iceberg");
var flashBlizzardAlert = warningMaker("flash blizzard");
var snowYetiAlert = warningMaker("snow yeti");

killerPenguinAlert(6, "Ice Caves");
snowYetiAlert(1, "Blizzard Beach");
```

_Пояснение._
Таким образим, с помощью замыканий функцию можно сделать более гибкой.

# 2.9 Раздел 2 - Изменение связанных значений после замыкания


## 2.10 Изменение связанного значения I

_Задание._
Разработчики the Cold Closures Cove обеспокоены количеством предупреждений, которые были возвращенны из the Cove Rangers в последнее время. Некоторые препятствия были  особенно хлопотны, а другие - нет, как обычные угрозы. Они хотели бы изменить предупреждающую функцию, чтобы внутри неё подсчитывалось количество возникновения препятствий, а затем добавить полученное число в предупреждающее сообщение. Опять же, не нужно передавать в вычисления само количество, но каждое сообщение функции выводит сохранённый подсчёт.
Формат нового сообщения должен соответствовать нижеследующему, можно использовать count в качестве трекера в новом конструкции:
```
"Beware! There have been <obstacle> sightings in the Cove today!
<number> <obstacle>(s) spotted at the <location>!
This is Alert #<count> today for <obstacle> danger."
```

_Решение._
В готовую функцию добавляем переменную count со значением 0 во внешней переменной, а во внутренней используем декрементный синтаксис:
```javascript
function warningMaker(obstacle) {
    var count = 0;
    return function (number, location) {
        count++;
        alert("Beware! There have been " + obstacle +
            " sightings in the Cove today!\n" +
            number + " " + obstacle + "(s) spotted at the " + location + "!\n" +
						"This is Alert #" + count + " today for <obstacle> danger."
        );
    };
}
```
Теперь при каждом вызове будет выводиться новое количетво препятствий.

_Пояснение._
Замыкающие функции могут даже модифицировать связанные переменные в фоновом режиме. Начинают такой трекер с 0, а затем добавляют по одному номеру. В нашем случае это так, но значения переменной могут варьироваться. После каждого запроса будет выводиться новое значение переменной.

## 2.11 Шоссе к Опасной зане

_Задание._
Тревога: Трудный вызов!
Теперь, когда оповещения эффективно учитываются для конкретного препятствия, the Dev Girls должны хранить известные места препятствий, так что список опасных зон для каждого препятствия может быть представлен с каждым новым предупреждением (они работают на дистанционным управлением лазерной акулы и действительно имеют мало времени). 
Используя замыкание в созданном предупреждении, найти способ для хранения каждого нового местоположения в массиве zones, а затем сообщить весь список текущих опасных зон в каждом предупреждении, которое выходит для этого конкретного препятствия. Новое сообщение оповещения должен быть следующим:
```
"Beware! There have been <obstacle> sightings in the Cove today!
<number> <obstacle>(s) spotted at the <location>!
This is Alert #<count> today for <obstacle> danger.
Current danger zones are:
<zone1>
<zone2>
<zone3>
..."
```
Конкретный пример этого нового предупреждения был бы:
```
Beware! There have been giant ice bat sightings in the Cove today!
20 giant ice bat(s) spotted at the Frozen Falls!
This is Alert #3 today for giant ice bat danger.
Current danger zones are:
Blizzard Beach
Ice Caves
Frozen Falls
```
Можно открыть консоль JavaScript браузера и проверить свой ​​код, чтобы увидеть всплывающие окна.

_Решение._
Во внешней функции создаём пустой массив zones, в который затем, с помощью метода .push() добавляем местоположения. Переменной list задаём пустую строку; в последствии эту переменную преобразуем в цикле и выведем в сообщении:
```javascript
function warningMaker(obstacle) {
    var count = 0;
    var zones = [];
    return function (number, location) {
        count++;
        zones.push(location);
        var list = "";
        for (var i = 0; i < zones.length; i++) {
            list = list + "\n" + zones[i];
        }
        alert("Beware! There have been " + obstacle +
            " sightings in the Cove today!\n" +
            number + " " + obstacle + "(s) spotted at the " + location + "!\n" +
            "This is Alert #" + count + " today for " + obstacle + " danger.\n" +
            "Current danger zones are:" + list
        );
    };
}
```

_Пояснение._
Хорошая практика - часто проверять свои шаги, выводя их в консоль. Это поможет глубже понять происходящее и вовремя скорректировать дальнейший код.

## 2.12 Просто следите за всем! Я всё скажу вам!

_Задание._
Тревога: Трудный вызов!
Для новых путешественников приятно узнать, где опасные зоны, но что, если некоторые из них ищут новые ощущения? Некоторые хотят знать как много препятствий в каждой опасной зоне: достаточно страшно, чтобы только получить адреналин, а не мгновенную смерть.
The Dev Girls на the Cove попросили теперь найти способ для хранения как расположения, так и количества препятствий, выводя оба в сообщении в следующем формате: 
```
"Beware! There have been <obstacle> sightings in the Cove today!
<number> <obstacle>(s) spotted at the <location>!
This is Alert #<count> today for <obstacle> danger. 
Current danger zones are:
<zone1> (<number1>)
<zone2> (<number2>)
<zone3> (<number3>)
..."
```
Конкретный пример этого нового предупреждения был бы:
```
"Beware! There have been giant ice bat sightings in the Cove today!
20 giant ice bat(s) spotted at the Frozen Falls!
This is Alert #3 today for giant ice bat danger.  
Current danger zones are:
Blizzard Beach (3)
Ice Caves (12)
Frozen Falls (20)"
```
Продолжаем использовать массив zones и на стесняемся использовать консоль.

_Решение._
Тут всё очень просто, вместо локации помещаем в массив другой массив с локацией, требуемым синтаксисом и количеством:
```javascript
function warningMaker(obstacle) {
    var count = 0;
    var zones = [];
    return function (number, location) {
        count++;
        zones.push([location + " (" + number + ")"]);
        var list = "";
        for (var i = 0; i < zones.length; i++) {
            list = list + "\n" + zones[i];
        }
        alert("Beware! There have been " + obstacle +
            " sightings in the Cove today!\n" +
            number + " " + obstacle + "(s) spotted at the " + location + "!\n" +
            "This is Alert #" + count + " today for " + obstacle + " danger.\n" +
            "Current danger zones are:" + list
        );
    };
}
```

_Пояснение._
Работа с массивами в js занимает далеко не последнее место в любой части кода, особенно когда дело касается функции. Поэтому важно научиться использовать полученные знания в комплексе