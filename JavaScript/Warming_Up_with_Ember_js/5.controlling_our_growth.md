# 5.1 Контроллеры массива

## 5.2 Сортировка и свойства для Products

_Задание._
Продукты на странице выглядят немного запутанно, а данные, которые должны гибко изменяться, необоснованно захардкоженны.   
    1) Создать контроллер для пути products. Мы будем использовать его для сортировки продуктов на странице, так что использовать правильный тип контроллера.  
    2) Отсортировать продукты по заголовку.   
    3) Создать объект пути для homepage.   
    4) Добавить функцию model для пути homepage, которая будет возвращать все продукты.    
    5) Изменить IndexController для ArrayController.   
    6) Обновить свойство productsCount в IndexController используя вычисляемые свойства.  

_Решение._
В файле app.js создадим контроллер для Products с помощью расширения Ember.ArrayController и отсортируем в нём товары по свойству title в алфавитном порядке. Контроллер Index также заменим на ArrayController, а свойству productsCount дадим значение не конкретного числа, а функции, подсчитывающей длинну массива. Кроме того, создадим расширение Route для Index, а в нём метод model, который отыскивает все продукты:   
```javascript
App.IndexController = Ember.ArrayController.extend({
    productsCount: function () {
        return this.get('length');
    }.property('length'),
    logo: 'images/logo-small.png',
    time: function () {
        return (new Date()).toDateString();
    }.property()
});

App.ProductsController = Ember.ArrayController.extend({
    sortProperties: ['title']
});

App.IndexRoute = Ember.Route.extend({
    model: function () {
        return this.store.findAll('product');
    }
});

App.Product.FIXTURES = [
    {  id: 1,
        title: 'Flint',
        price: 99,
        description: 'Flint is a hard, sedimentary cryptocrystalline form of the mineral quartz, categorized as a variety of chert.',
        isOnSale: true,
        image: 'images/products/flint.png',
        reviews: [100, 101],
        crafter: 200
    },
    {
        id: 2,
        title: 'Kindling',
        price: 249,
        description: 'Easily combustible small sticks or twigs used for starting a fire.',
        isOnSale: false,
        image: 'images/products/kindling.png',
        reviews: [],
        crafter: 201
    },
    {
        id: 3,
        title: 'Matches',
        price: 499,
        description: 'One end is coated with a material that can be ignited by frictional heat generated by striking the match against a suitable surface.',
        isOnSale: true,
        reviews: [103],
        image: 'images/products/matches.png',
        crafter: 201
    },
    {
        id: 4,
        title: 'Bow Drill',
        price: 999,
        description: 'The bow drill is an ancient tool. While it was usually used to make fire, it was also used for primitive woodworking and dentistry.',
        isOnSale: false,
        reviews: [104],
        image: 'images/products/bow-drill.png',
        crafter: 200
    },
    {
        id: 5,
        title: 'Tinder',
        price: 499,
        description: 'Tinder is easily combustible material used to ignite fires by rudimentary methods.',
        isOnSale: true,
        reviews: [],
        image: 'images/products/tinder.png',
        crafter: 201
    },
    {
        id: 6,
        title: 'Birch Bark Shaving',
        price: 999,
        description: 'Fresh and easily combustable',
        isOnSale: true,
        reviews: [],
        image: 'images/products/birch.png',
        crafter: 200
    }
];
```

_Пояснение._
В беспорядочном списке легко запутаться, поэтому его нужно отсортировывать. С этой задачей справляется свойство контроллера sortProperties. Оно отсортировывает требуемые данные в алфавитном порядке. Но для этого нам нужен специальный контроллер, который знает, что он будет иметь дело с массивом. Таким контроллером является Ember.ArrayController.    
Если нам нужно гибко подсчитывать количество чего-либо на странице, к примеру продуктов, для начала установим соответствующую модель. Затем изменим тип контроллера на ArrayController,чтобы он мог подсчитывать элементы массива. И, в конце концов, передадим метод, который возвращает длину массива (this.get('length')).

## 5.3 Сортировка и свойства для Contacts

_Задание._
Используя наши новые знания о контроллерах, приведём в порядок страницу Contacts.   
    1) Создать контроллер для пути contacts. Мы будем использовать его для сортировки контактов на странице.  
    2) Отсортировать контакты по имени.   
    3) Мы хардкодим "Anostagia" в контроллере ContactsIndex, но мы можем вернуть имя из модели. Создав объект пути обеспечить модель им.      
    4) Обеспечить модель для ContactsIndex Route, которая будет иметь только одну модель - контакт для Anostagia. Его можно найти по ID.    
    5) Теперь ContactsIndexController опирается только на один объект. Обновить тип контроллера для отображения контента позади него.   
    6) Обновить свойство contactName используя иное вычисление на Ember.  

_Решение._
Создадим контроллер для массива контактов, в котором отсортируем свойства name по алфавиту. Создадим расширение Route для ContactsIndex, где в контактах отыщем тот, у которого id 201. Далее изменим тип контроллера ContactsIndex, а его свойству contactName дадим значение Ember.computed.alias, передав в него свойство name:
```javascript
App.ContactsIndexController = Ember.ObjectController.extend({
    contactName: Ember.computed.alias('name'),
    avatar: 'images/avatar.png',
    open: function () {
        return ((new Date()).getDay() === 0) ? "Closed" : "Open";
    }.property()
});

App.ContactsController = Ember.ArrayController.extend({
    sortProperties: ['name']
});

App.ContactsIndexRoute = Ember.Route.extend({
    model: function () {
        return this.store.find('contact', 201);
    }
});

App.Contact.FIXTURES = [
    {
        id: 200,
        name: 'Giamia',
        about: 'Although Giamia came from a humble spark of lightning, he quickly grew to be a great craftsman, providing all the warming instruments needed by those close to him.',
        avatar: 'images/contacts/giamia.png',
        products: [1]
    },
    {
        id: 201,
        name: 'Anostagia',
        about: 'Knowing there was a need for it, Anostagia drew on her experience and spearheaded the Flint & Flame storefront. In addition to coding the site, she also creates a few products available in the store.',
        avatar: 'images/contacts/anostagia.png',
        products: [2]
    }
];
```

_Пояснение._
Контроллеры могут быть не только для массивов, но и для объектов (Ember.ObjectController). Второй вид используется, когда мы работаем со свойствами одного объекта. В наших упражнениях мы сортировали свойства по алфавиту. Если нам нужен обратный алфавитный порядок, установим sortAscending в  false. Стоит также отметить, что в предыдущем упражнении, в свойстве productsCount для нахождения длины массива мы могли бы использовать Ember.computed.alias(), передав ему length. Оба эти варианта равнозначны. 

# 5.4 Вычисленные свойства

## 5.5 Фильтрация контроллера

_Задание._
На сайте отобразим 3 продукта, которые находятся на распродаже так, чтобы иметь возможность удалить их, когда распродажа закончится.   
    1) Мы хотим представить список элементов из распродажи на homepage. Добавить свойство onSale для IndexController, которое вернёт продукты со скидкой.    
    2) В свойстве onSale отфильтровать продукты только находящиеся на распродаже и только 3 из них.   
    3) В шаблоне index пройтись циклом по элементам onSale и выписать title, description и price. Также добавить ссылку на каждый из продуктов.    
    4) Выглядит хорошо, теперь последний шаг, сделаем автоматическое обновление при отмене скидок на товары. Вернуться в indexController и отредактировать свойство, которое мы возвращаем чтобы наблюдать за изменениями атрибута isOnSale.

_Решение._
В контроллер для главной страницы добавим метод onSale, который вернёт отфильтрованные по свойству isOnSale товары в количестве 3 и сделаем возможность убрать их со страницы при отмене скидок.  В HTML отобразим заголовок, описание и цену каждого элемента, прошедшего фильтр onSale:   
app.js:
```javascript
App.IndexController = Ember.ArrayController.extend({
    productsCount: Ember.computed.alias('length'),
    logo: 'images/logo-small.png',
    time: function () {
        return (new Date()).toDateString();
    }.property(),
    onSale: function () {
        return this.filterBy('isOnSale').slice(0, 3);
    }.property('@each.isOnSale')
});
```
index.html:
```html
<script type='text/x-handlebars' data-template-name='index'>
    ...
    {{#each onSale}}
    <div class='col-sm-4'>
        <h2>{{title}}</h2>

        <p class="product-description">{{description}}</p>

        <p>{{#link-to 'product' this class='btn btn-success'}}
            Buy for ${{price}}
            {{/link-to}}</p>
    </div>
    {{/each}}
</script>
```

_Пояснение._
Сделать часто меняющийся список без лишнего хардкодинга можно с помощью фильтрующего метода filterBy() контроллеров. Этот метод принимает в качестве первого аргумента свойтво, которое будет фильтроваться, а в качестве второго - условие. По умолчанию условие true, так что его можно опускать. Чтобы вывести какое-то конкретное количество объектов, используют метод JavaScript
slice(). Чтобы следить за изменениями свойств, используют @each.имяСвойства, помещённый в качестве параметра в метод .property() после определения фильтрующего метода.

## 5.6 Фильтрация по цене

_Задание._
На некоторые продукты у нас появляется больше отзывов и мы хотим выделить такие продукты. Обновим маршрут products index - тот, где пользователь кликает "Products" в панеле навигации - отобразим все продукты дешевле $500.    
    1) Первым шагом для выбора некоторого количества (продуктов дешевле $500) создать ProductsIndexRoute. Затем, внутри нашего нового пути создать модель, которая вернёт все продукты.    
    2) Так как мы будем делать фильтрацию в контроллере, создать его для пути products/index.    
    3) В новом контроллере добавить метод deals.   
    4) Внутри deals вернуть все продукты с ценой меньше 500 путём фильтрации.   
    5) Модернизировать свойство deals для обновления всякий раз при изменении каждого из продуктов.   
    6) В шаблоне products index вывести title, description и price для каждого подходящего продукта. Также сделать ссылку на каждый из них.    

_Решение._
В app.js Создадим два новых расширения: для Route и для ArrayController. Они будут предназначены для ProductsIndex. В Route создадим метод model, возвращающий все найденные продукты, а в ArrayController - метод deals, возвращающий продукты, отфильтрованные по цене ниже 500. Кроме того, на методе deals вызовем property(), которому передадим обновление всякий раз при изменении цены. Последним шагом выведем в шаблоне products/index заголовок, описание и цену продуктов для каждого, соответствующего deals:   
app.js:
```javascript
App.ProductsIndexRoute = Ember.Route.extend({
    model: function () {
        return this.store.findAll('product');
    }
});

App.ProductsIndexController = Ember.ArrayController.extend({
    deals: function () {
        return this.filter(function (product) {
            return product.get('price') < 500;
        });
    }.property('@each.price')
});
```
index.html:
```html
<script type='text/x-handlebars' data-template-name='products/index'>
    <p class='text-muted'>Choose a product from those on the left!</p>

    <div class='row'>
        {{#each deals}}
            <h2>{{title}}</h2>
    
            <p class="product-description">{{description}}</p>
    
            <p>{{#link-to 'product' this class='btn btn-success'}}
                Buy for ${{price}}{{/link-to}}</p>
        {{/each}}
    </div>
</script>
```

_Пояснение._
Иногда метод filterBy() не справляется с требуемыми задачами. Тогда применяем filter(), принимающий коллбек с аргументом, возвращающий метод get('свойство') на этом аргументе.

# 5.7 Вложенные маршруты с контроллерами

## 5.8 Использование вложенных путей

_Задание._
Следующим шагом изменим страницу products для использования просмотра деталей путём переключения, применяя вложенные маршруты. Создадим новый путь для продуктов с распродажи и сошлёмся на него.   
    1) Создать новый путь onsale под родительским путём Products.   
    2) Создать новый путь onsale, класс которого соответствует нашему новому только что созданному пути.    
    3) Реализовать для этого пути функцию model. Прежде, чем запросить продукты, использовать только эту модель из пути products. Отсортировать продукты, выбрав только те, которые на распродаже.    
    4) В шаблоне index, при отображении продуктов со скидками, добавить ссылку на все распродающиеся продукты.    
    5) Далее нужно создать шаблон для пути products.onsale. Дать ему подходящее имя в index.html.   
    6) Заполнить шаблон только что созданными product details. Создать неупорядоченный список, отображающий все продукты в модели. Заполните шаблон, который мы только что создали product details. Убедиться, что тэг img включен с image, как title, description и price и сослаться на продукты.   

_Решение._
В Router.map() добавим дочерний путь к products для onsale. Затем для этого пути создадим расширение Route, в которое поместим модель, возвращающую родительскую, отфильтрованную по наличию на распродаже. В файле HTML создадим шаблон products/onsale для вывода всех товаров с распродажи с их изображениями, заголовком, описанием и ценой, а в шаблоне index добавим ссылку на них с помощью products.onsale:   
app.js:
```javascript
App.Router.map(function () {
    this.route('credits', { path: '/thanks' });
    this.resource('products', function () {
        this.resource('product', { path: '/:product_id' });
        this.route('onsale');
    });
    this.resource('contacts', function () {
        this.resource('contact', { path: '/:contact_id' });
    });
});

App.ProductsOnsaleRoute = Ember.Route.extend({
    model: function () {
        return this.modelFor('products').filterBy('isOnSale');
    }
});
```
index.html:
```html
<script type='text/x-handlebars' data-template-name='index'>
    ...
    <div class='row'>
        {{#each onSale}}
        <div class="col-sm-4">
            <img {{bind-attr src='image'}} class='img-thumbnail col-sm-5' />
            <div class="col-sm-7">
                <h2>{{title}}</h2>
            <span class='label label-warning'>
              {{#link-to 'products.onsale'}}On Sale{{/link-to}}
            </span>

                <p class="product-description">{{description}}</p>

                <p>{{#link-to 'product' this class='btn btn-success'}}
                    Buy for ${{price}}{{/link-to}}</p>
            </div>
        </div>
        {{/each}}
    </div>
    <p class='pull-right text-muted'>Rendered on {{time}}</p>
</script>
<script type='text/x-handlebars' data-template-name='products/onsale'>
    <ul class='list-unstyled'>
        {{#each}}
        <li class='row'>
            <img {{bind-attr src='image'}} class='img-thumbnail col-sm-5'/>
            <div class='col-sm-7'>
                <h2>{{title}}</h2>

                <p class='product-description'>{{description}}</p>

                <p>{{#link-to 'product' this class='btn btn-success'}}
                    Buy for ${{price}}{{/link-to}}</p>
            </div>
        </li>
        {{/each}}
    </ul>
</script>
```

_Пояснение._
Ещё один способ, по которому можно отличить route от resource заключается в том, что в качестве первого аргумента route может принимать глаголы, прилагательные и наречия, а resource только существительные. Если путь имеет родителя, то его всегда нужно указывать в качестве префикса. modelFor возвращает модель от заданного родительского маршрута. Чтобы сослаться на чей-то дочерний путь, используем точку: родитель.ребёнок, тогда как при создании дочернего шаблона используем бэкслеш: родитель/ребёнок, а свойство path будет выглядеть так: #/родитель/ребёнок.

## 5.9 Помещённый путь Deals 

_Задание._
Немного подумав, было принято решение создать новую страницу Deals, которая выводит список только продуктов дешевле $500.   
    1) Создать новый путь deals под родительским путём Products.   
    2) Создать объект Route для нового пути, который использует modelFor и фильтрует продукты дешевле $500.   
    3) В шаблоне products сделать ссылку для путей Deals и On Sale.       
    4) Создать новый шаблон products/deals, который буем использовать для вывода всех продуктов deals.    
    5) Вывести список всех продуктов deals внутри products/deals. Нужно убедиться, что используется такая же разметка, как и в products/onsale.    
    6) Изменить страницу products для вывода списка всех продуктов, а не только тех, которые на распродаже. Во-первых удалить ProductsIndexController (мы не хотим больше фильтровать продукты по цене). Затем, внутри шаблона products/index пройтись циклом по всем продуктам, а не только по deals.

_Решение._
Теперь создадим путь для deals, а также расширение Route, в котором возьмём родительскую модель и отфильтруем все продукты в ней по цене. Контроллер для ProductsIndex, который раньше делал эту работу, больше не нужен, поэтому удалим его. Немного изменим HTML так, чтобы на главной странице с продуктами выводились все товары, а над боковой панелью со списком можно было бы сослаться на те, которые со скидкой и на те, который дешевле $500:     
app.js:
```javascript
App.Router.map(function () {
    this.route('credits', { path: '/thanks' });
    this.resource('products', function () {
        this.resource('product', { path: '/:product_id' });
        this.route('onsale');
        this.route('deals');
    });
    this.resource('contacts', function () {
        this.resource('contact', { path: '/:contact_id' });
    });
});
App.ProductsDealsRoute = Ember.Route.extend({
    model: function () {
        return this.modelFor('products').filter(function (product) {
            return product.get('price') < 500;
        });
    }
});
```
index.html:
```html
<!DOCTYPE html>
<html>
<head>
    ...
</head>
<body>
<script type='text/x-handlebars' data-template-name='application'>
    ...
</script>
<script type='text/x-handlebars' data-template-name='index'>
    ...
</script>
<script type='text/x-handlebars' data-template-name='contacts/index'>
    ...
</script>
<script type='text/x-handlebars' data-template-name='credits'>
    ...
</script>
<script type='text/x-handlebars' data-template-name='products'>
    <div class='row'>
        <div class='col-sm-3'>
            <div class='list-group'>
                {{#link-to 'products.deals'}}See all deals{{/link-to}}
                {{#link-to 'products.onsale'}}See all products on sale{{/link-to}}
            </div>
            <div class='list-group'>
                {{#each}}
                {{#link-to 'product' this classNames='list-group-item'}}
                {{title}}
                {{/link-to}}
                {{/each}}
            </div>
        </div>
        <div class='col-sm-9'>
            {{outlet}}
        </div>
    </div>
</script>
<script type='text/x-handlebars' data-template-name='products/deals'>
    <ul class='list-unstyled'>
        {{#each}}
        <li class='row'>
            <img {{bind-attr src='image'}} class='img-thumbnail col-sm-5' />
            <div class='col-sm-7'>
                <h2>{{title}}</h2>

                <p class='product-description'>{{description}}</p>

                <p>{{#link-to 'product' this class='btn btn-success'}}
                    Buy for ${{price}}{{/link-to}}</p>
            </div>
        </li>
        {{/each}}
    </ul>
</script>
<script type='text/x-handlebars' data-template-name='product'>
    ...
</script>
<script type='text/x-handlebars' data-template-name='products/index'>
    <h1>All Products</h1>
    <ul class='list-unstyled'>
        {{#each}}
        <li class='row'>
            <img {{bind-attr src='image'}} class='img-thumbnail col-sm-5' />
            <div class='col-sm-7'>
                <h2>{{title}}</h2>

                <p class='product-description'>{{description}}</p>

                <p>{{#link-to 'product' this class='btn btn-success'}}
                    Buy for ${{price}}{{/link-to}}</p>
            </div>
        </li>
        {{/each}}
    </ul>
</script>
<script type='text/x-handlebars' data-template-name='contacts'>
    ...
</script>
<script type='text/x-handlebars' data-template-name='contact'>
    ..
</script>
<script type='text/x-handlebars' data-template-name='products/onsale'>
    ...
</script>
</body>
</html>
```

_Пояснение._
Когда мы выводим не какие-то определённые элементы (в нашем случае продукты), в {{#each}} не нужно помещать уточнений (как в случае с отзывами {{#each reviews}}). 