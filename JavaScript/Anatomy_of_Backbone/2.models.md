# 2.1 Модели

## 2.2 Значения по умолчанию

_Задание._
Модель Appointment ещё не кажется действительно полезной. Добавим 2 атрибута по умолчанию: title в качестве строки "Checkup" и date, который по умолчанию должен содержать текущее время new Date().

_Решение._
В объект аргумента расширения модели Backbone поместим объект defaults с требуемыми атрибутами:
```javascript
var Appointment = Backbone.Model.extend({
    defaults: {
        title: 'Checkup',
        date: new Date()
    }
});
```

_Пояснение._
Метод extend() модели может принимать в качестве аргумента(ов) различные свойства. Чтобы некоторые атрибуты использовались по умолчанию, применяют свойство [defaults](http://backbonejs.ru/#Model-defaults).

## 2.3 Исправление значений по умолчанию

_Задание._ 
В консоли обнаружен странный баг. Каждый новый Appointment имеет  ту же самую дату вместо даты и времени создания экземпляра.   
Это потому, что new Date() определялась один раз, когда впервые была создана модель Appointment, а не переопределялась каждый раз при создании нового экземпляра.   
Чтобы исправить это, присвоим defaults функцию, а не просто объект. А объект перенесём в функцию, чтобы она его возвращала. Это придаст большую гибкость и заставит дефолтное время вычисляться каждый раз при создании нового экземпляра.

_Решение._
Сделаем так, чтобы свойство defaults имело в качестве значения не просто объект, а возвращаемый функцией объект: 
```javascript
var Appointment = Backbone.Model.extend({
    defaults: function () {
        return {
            title: 'Checkup',
            date: new Date()
        }
    }
});
```

_Пояснение._
В JavaScript объекты передаются по ссылке, так что, если какое-либо значение по умолчанию будет объектом, оно будет одним для всех экземпляров. Вместо этого определим defaults как функцию.

## 2.4 Выборка с url

_Задание._
Dr. Goodparts заканчивал рассматривать сервер и заметил неверные url. К счастью для нас, у него есть пакет REST с JSON.   
Направим корневой url модели Appointment в конечную точку /appointments.   
Затем создадим новый Appointment с id 1 и сделаем выборку соответствующих данных из сервера.

_Решение._
В объекте аргумента расширения модели Backbone укажем адрес корневого url. Затем создадим новый Appointment с id 1 и сделаем выборку соответствующих данных из сервера:
```javascript
var Appointment = Backbone.Model.extend({urlRoot: '/appointments'});
var appointment = new Appointment({id: 1})
appointment.fetch();
```

_Пояснение._
По умолчанию, url возвращает относительный URL, по которому ресурс модели должен располагаться на сервере и обращается к Collection#url, чтобы сгенерировать его. Для генерации метода исходя из id, используется свойство [urlRoot](http://backbonejs.ru/#Model-urlRoot). Чтобы обновить данные с сервера, используем метод [fetch()](http://backbonejs.ru/#Model-fetch).

## 2.5 Синхронизация изменений

_Задание._
Установка urlRoot модели Appointment позволяет нам делать болше, чем просто выборку из сервера, это также даёт нам возможность синхронизировать изменения, сделанные для экземпляров модели.   
Dr. Goodparts чувствует себя сегодня не хорошо, так что нам нужно отменить его встречи. Установим атрибут cancelled в true и сохраним appointment для сервера.

_Решение._
С помощью метода set установим значение атрибута cancelled true, а затем сохраним изменения:
```javascript
var appointment = new Appointment({id: 1});
appointment.set({cancelled: true});
appointment.save();
```

_Пояснение._
Метод [save()](http://backbonejs.ru/#Model-save) сохраняет модель в базу данных.

## 2.6 Прослушивание для изменений

_Задание._
Dr. Goodparts растроился, что он не был уведомлён, когда мы отменили его последнюю встречу.   
Добавим слушателя для экземпляра модели appointment, чтобы всякий раз при изменении атрибутов модели всплывало окно предупреждения (alert) .

_Решение._
Создадим слушателя события change, в котором будет выводиться всплывающее окно при любом изменении атрибутов:
```javascript
var appointment = new Appointment({id: 1});
appointment.on('change', function () {
    alert('change is happened!');
});
```

_Пояснение._
На моделях можно создавать обработчики событий для их привязки используют метод [on()](http://backbonejs.ru/#Events-on).

## 2.7 Меньше прослушивания

_Задание._
Браузер Dr. Goodparts потерпел крушение из-за слишком большого количества предупреждений.   
Вместо прослушивания всех изменённых атрибутов, прослушаем и предупредим только когда изменения сделаны для атрибута cancelled.

_Решение._
Укажем, что прослушиваться должно только изменение атрибута cancelled:
```javascript
appointment.on('change:cancelled', function () {
    alert("Hey Dr. Goodparts, your appointment has changed!");
});
```

_Пояснение._
Чтобы из множества подобных событий выбрать одно, используют двоеточие ('событие:конкретизация') без пробела. В случае, если нужно обработать несколько событий, стоит просто разделить их пробелом ('событие:конкретизация ещёСобытие:ещёКонкретизация').

## 2.8 Возвращая наши атрибуты

_Задание._
Мы [уже видели](https://github.com/preigile/codeschool-hints/blob/master/JavaScript/Anatomy_of_Backbone/1.introduction.md#16-%D0%9E%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2%D0%B8%D0%B7%D1%83%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8), как можно использовать get для доступа к атрибутам в экземпляре модели, но что если мы хотим их все сразу?   
Используем функцию console.log для лога JSON экземпляра appointment с помощью toJSON.

_Решение._
Выведем в консоль JSON экземпляра appointment:
```javascript
var appointment = new Appointment({id: 1});
console.log(appointment.toJSON());
```

_Пояснение._
С помощью метода [toJSON()](http://backbonejs.ru/#Model-toJSON) (model.toJSON()) можно вернуть копию поля attributes для превращения в JSON-строку.
