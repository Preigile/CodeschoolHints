# 2.1 Модели

## 2.2 Значения по умолчанию

_Задание._
Модель Appointment ещё не кажется действительно полезной. Добавим 2 атрибута по умолчанию: title в качестве строки "Checkup" и date, который по умолчанию должен содержать текущее время new Date().

_Решение._
В объект аргумента расширения модели Backbone поместим объект defaults с требуемыми атрибутами:
```javascript
var Appointment = Backbone.Model.extend({
    defaults: {
        title: 'Checkup',
        date: new Date()
    }
});
```

_Пояснение._
Метод extend() модели может принимать в качестве аргумента(ов) различные свойства. Чтобы некоторые атрибуты использовались по умолчанию, применяют свойство [defaults](http://backbonejs.ru/#Model-defaults).

## 2.3 Исправление значений по умолчанию

_Задание._ 
В консоли обнаружен странный баг. Каждый новый Appointment имеет  ту же самую дату вместо даты и времени создания экземпляра.   
Это потому, что new Date() определялась один раз, когда впервые была создана модель Appointment, а не переопределялась каждый раз при создании нового экземпляра.   
Чтобы исправить это, присвоим функцию для defaults, а не просто объект. Перенесём объект ниже, в функцию, которая будет его возвращать. Это приведёт к тому, что по умолчанию будет вычистятся время создания каждого нового экземпляра.

_Решение._
Сделаем так, чтобы свойство defaults имело в качестве значения не просто объект, а возвращаемый функцией объект: 
```javascript
var Appointment = Backbone.Model.extend({
    defaults: function () {
        return {
            title: 'Checkup',
            date: new Date()
        }
    }
});
```

_Пояснение._
В JavaScript объекты передаются по ссылке, так что, если какое-либо значение по умолчанию будет объектом, оно будет одним для всех экземпляров. Вместо этого определим defaults как функцию.

## 2.4 Выборка с url

_Задание._
Dr. Goodparts заканчивал расплачиваться за сервер и заметил это с его несколькими первыми встречами. К счастью для нас, он купил пакет REST с дополнением JSON.   
Направим корневой url модели Appointment в конечную точку /appointments.   
Затем, создадим новый Appointment с id 1 и сделаем выборку этих данных из сервера.

_Решение._
В объект аргумента расширения модели Backbone укажем адрес корневого url. Затем создадим новый Appointment с id 1 и сделаем выборку этих данных из сервера:
```javascript
var Appointment = Backbone.Model.extend({urlRoot: '/appointments'});
var appointment = new Appointment({id: 1})
appointment.fetch();
```

_Пояснение._
По умолчанию, url возвращает относительный URL, по которому ресурс модели должен располагаться на сервере и обращается к Collection#url, чтобы сгенерировать его. Чтобы генерировать методы исходя из id, используется свойство [urlRoot](http://backbonejs.ru/#Model-defaults). Чтобы обновить данные с сервера, используем метод [fetch()](http://backbonejs.ru/#Model-fetch).

## 2.5 Синхронизация изменений

_Задание._
Установка urlRoot модели Appointment позволяет нам делать болше, чем просто выборку из сервера, оно также даёт нам возможность синхронизировать изменения сделанные для экземпляров модели.   
Dr. Goodparts чувствует себя сегодня не хорошо, так что нам нужно отменить его встречи. Установим атрибут cancelled в true и сохраним appointment для сервера.

_Решение._
С помощью метода set установим значение атрибута cancelled true, а затем сохраним это:
```javascript
var appointment = new Appointment({id: 1});
appointment.set({cancelled: true});
appointment.save();
```

_Пояснение._
Метод [save()](http://backbonejs.ru/#Model-save) сохраняет модель в базу данных.

## 2.6 Прослушивание для изменений

_Задание._
Dr. Goodparts растроился, что он не был уведомлён, когда мы отменили его последнюю встречу.   
Добавим слушателя для экземпляра модели appointment для всплывающего окна предупреждения (используя alert) всякий раз при изменении атрибутов модели.

_Решение._
Создадим слушателя события change, в котором будет выводиться всплывающее окно при любом изменении атрибутов:
```javascript
var appointment = new Appointment({id: 1});
appointment.on('change', function () {
    alert('change is happened!');
});
```

_Пояснение._
На моделях можно создавать обработчики событий для их привязки используют метод [on()](http://backbonejs.ru/#Events-on).

## 2.7 Меньше прослушивания

_Задание._
Браузер Dr. Goodparts потерпел крушение из-за слишком большого количества предупреждений.   
Вместо прослушивания для всех изменённых атрибутов, прослушаем и предупредим только когда изменения сделаны для атрибута cancelled.

_Решение._
Укажем, что прослушиваться должно только изменение атрибута cancelled:
```javascript
appointment.on('change:cancelled', function () {
    alert("Hey Dr. Goodparts, your appointment has changed!");
});
```

_Пояснение._
Чтобы из множества подобных событий выбрать одно, используют двоеточие ('событие:конкретизация') без пробела. В случае, если нужно обработать несколько событий, стоит просто разделить их пробелом ('событие:конкретизация ещёСобытие:ещёКонкретизация').

## 2.8 Возвращая наши атрибуты

_Задание._
Мы уже видели, как можно использовать get для доступа к атрибутам в экземпляре модели, но что если мы хотим их все сразу?   
Используя функцию console.log для лога JSON экземпляра appointment с помощью toJSON.

_Решение._
Выведем в консоль JSON экземпляра appointment:
```javascript
var appointment = new Appointment({id: 1});
console.log(appointment.toJSON());
```

_Пояснение._
С помощью метода [toJSON()](http://backbonejs.ru/#Model-toJSON) (model.toJSON()) можно вернуть копию поля attributes для превращения в JSON-строку.
